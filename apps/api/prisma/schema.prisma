generator client {
  provider        = "prisma-client"
  output          = "../src/generated/prisma"
  previewFeatures = ["postgresqlExtensions"]
}

datasource db {
  provider   = "postgresql"
  url        = env("DATABASE_URL")
  directUrl  = env("DIRECT_URL")
  extensions = [vector]
}

/// This model or at least one of its fields has comments in the database, and requires an additional setup for migrations: Read more: https://pris.ly/d/database-comments
model documents {
  id                    String                 @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  content_hash          String                 @unique(map: "idx_documents_content_hash")
  filename              String
  mimetype              String
  size                  BigInt
  storage_path          String
  public_url            String
  storage_bucket        String
  /// Full extracted text from document - stored for reference and full-text search
  extracted_text        String?
  /// Character count of extracted text - used for metrics and debugging
  extracted_text_length Int?                   @default(0)
  /// Indicates if document has been chunked and embedded (true = chunks exist)
  has_embedding         Boolean?               @default(false)
  user_id               String?                @db.Uuid
  created_at            DateTime               @default(now()) @db.Timestamptz(6)
  updated_at            DateTime               @default(now()) @db.Timestamptz(6)
  /// Legacy single embedding field - no longer used (replaced by chunk embeddings)
  embedding             Unsupported("vector")?
  /// Relation to document chunks - one document has many chunks
  chunks                document_chunks[]

  @@index([created_at(sort: Desc)], map: "idx_documents_created_at")
  @@index([user_id], map: "idx_documents_user_id")
}

/// Stores text chunks from documents with their vector embeddings for semantic search.
/// Documents are split into overlapping chunks (1000 chars, 200 overlap) to enable
/// precise semantic search and handle large documents within embedding token limits.
model document_chunks {
  id          String                 @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  /// Foreign key to parent document - links chunk back to its source document
  document_id String                 @db.Uuid
  /// Position of chunk in document (0, 1, 2...) - used to retrieve chunks in order
  chunk_index Int
  /// The actual text content of this chunk - returned in search results
  content     String
  /// Estimated token count (~chars/4) - useful for cost tracking and debugging
  token_count Int?
  /// 3072-dimensional vector embedding from OpenAI (text-embedding-3-large)
  /// Used for cosine similarity search with pgvector's <=> operator
  embedding   Unsupported("vector")?
  /// JSON metadata storing chunk position info: chunkIndex, startPosition, endPosition, length
  /// Useful for highlighting matches and retrieving surrounding context
  metadata    Json?
  created_at  DateTime               @default(now()) @db.Timestamptz(6)
  document    documents              @relation(fields: [document_id], references: [id], onDelete: Cascade)

  @@unique([document_id, chunk_index], map: "idx_document_chunks_unique")
  @@index([document_id], map: "idx_document_chunks_document_id")
  message_sources message_sources[]
}

/// Stores chat conversations - each conversation is a separate chat session
model conversations {
  id         String    @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  /// Optional title for the conversation - can be auto-generated from first message
  title      String?
  /// Indicates whether the conversation has been escalated to a human agent
  is_escalated Boolean  @default(false)
  /// Optional escalation reason captured when the AI routes to a human
  escalated_reason String?
  /// Timestamp of when the conversation was escalated
  escalated_at DateTime? @db.Timestamptz(6)
  /// Indicates whether the conversation has been resolved by a human agent
  is_resolved Boolean @default(false)
  /// Timestamp of when the conversation was resolved
  resolved_at DateTime? @db.Timestamptz(6)
  /// Name of the agent that closed the conversation
  resolved_by String?
  /// (Optional) Name of the human agent that picked up the conversation
  agent_name String?
  /// Timestamp of when the agent joined the conversation
  agent_joined_at DateTime? @db.Timestamptz(6)
  created_at DateTime  @default(now()) @db.Timestamptz(6)
  updated_at DateTime  @default(now()) @db.Timestamptz(6)
  /// Relation to messages - one conversation has many messages
  messages   messages[]

  @@index([created_at(sort: Desc)], map: "idx_conversations_created_at")
  @@index([updated_at(sort: Desc)], map: "idx_conversations_updated_at")
  @@index([is_resolved, updated_at(sort: Desc)], map: "idx_conversations_resolved")
}

/// Stores individual messages in conversations (user and assistant messages)
model messages {
  id              String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  /// Foreign key to parent conversation
  conversation_id String            @db.Uuid
  /// Message role: "user", "assistant", or "system"
  role            String
  /// The text content of the message
  content         String
  created_at      DateTime          @default(now()) @db.Timestamptz(6)
  /// Relation to parent conversation
  conversation    conversations     @relation(fields: [conversation_id], references: [id], onDelete: Cascade)
  /// Relation to source chunks used to generate this message (for citations)
  sources         message_sources[]

  @@index([conversation_id], map: "idx_messages_conversation_id")
  @@index([created_at(sort: Desc)], map: "idx_messages_created_at")
}

/// Links messages with document chunks used as context (for citation tracking)
model message_sources {
  id               String          @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  /// Foreign key to the message this source was used for
  message_id       String          @db.Uuid
  /// Foreign key to the document chunk that was used as context
  chunk_id         String          @db.Uuid
  /// Cosine similarity score (0-1) from vector search - indicates relevance
  similarity_score Float
  created_at       DateTime        @default(now()) @db.Timestamptz(6)
  /// Relation to parent message
  message          messages        @relation(fields: [message_id], references: [id], onDelete: Cascade)
  /// Relation to document chunk used as source
  chunk            document_chunks @relation(fields: [chunk_id], references: [id], onDelete: Cascade)

  @@index([message_id], map: "idx_message_sources_message_id")
  @@index([chunk_id], map: "idx_message_sources_chunk_id")
}
